{% extends "main/base_block_project.html" %}
{% load static %}
{% block content_body %}
<h2 class="mb-5">Jellyfin Music Organizer v3.06</h2>
<h3 class="mb-3">Image</h3>
<img class="proj-pic-item mb-5" src="{% static 'portfolio_app/img/projects/jellyfin_music_organizer.png' %}" alt="..." />
<h3 class="mb-3">Code (main.py)</h3>
<pre class="mb-3"><code class="language-python">
from PyQt5.QtWidgets import QApplication
import qdarkstyle

# Other classes within files
from music_organizer import MusicOrganizer

# Create and run application
if __name__ == '__main__':
    app = QApplication([])
    app.setStyleSheet(qdarkstyle.load_stylesheet_pyqt5())
    window = MusicOrganizer()
    app.exec_()
        
</code></pre>
<h3 class="mb-3">Code (music_organizer.py)</h3>
<pre class="mb-3"><code class="language-python">
from PyQt5.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, QProgressBar, QApplication, QFileDialog, QSizeGrip, QSpacerItem, QSizePolicy)
from PyQt5.QtCore import Qt
from PyQt5.QtGui import QIcon
import json
from resources_rc import *

# Other classes within files
from notification_audio_thread import NotificationAudioThread
from organize_thread import OrganizeThread
from custom_dialog import CustomDialog
from music_error_window import MusicErrorWindow
from replace_skip_window import ReplaceSkipWindow
from settings_window import SettingsWindow

class MusicOrganizer(QWidget):
    def __init__(self):
        super().__init__()

        # Version Control
        self.version = '3.06'

        # Set default settings
        self.music_folder_path = ''
        self.destination_folder_path = ''

        # Setup and show user interface
        self.setup_ui()

        # Load settings from file if it exists
        self.load_settings()

        # Show starting window
        self.show()

    def showEvent(self, event):
        super().showEvent(event)
        self.center_window()

    def setup_titlebar(self):
        # Hides the default titlebar
        self.setWindowFlag(Qt.FramelessWindowHint)

        # Title bar widget
        self.title_bar = QWidget(self)
        self.title_bar.setObjectName("TitleBar")
        self.title_bar.setFixedHeight(32)

        hbox_title_layout = QHBoxLayout(self.title_bar)
        hbox_title_layout.setContentsMargins(0, 0, 0, 0)

        self.icon_label = QLabel()
        self.icon_label.setPixmap(QIcon(':/Octopus.ico').pixmap(24, 24))
        hbox_title_layout.addWidget(self.icon_label)

        self.title_label = QLabel(f"Music Organizer v{self.version}")
        self.title_label.setStyleSheet("color: white;")
        hbox_title_layout.addWidget(self.title_label)

        hbox_title_layout.addStretch()

        self.settings_button = QPushButton("⚙")
        self.settings_button.setToolTip('Settings')
        self.settings_button.setFixedSize(24, 24)
        self.settings_button.setStyleSheet(
            "QPushButton { color: white; background-color: transparent; }"
            "QPushButton:hover { background-color: blue; }"
        )
        hbox_title_layout.addWidget(self.settings_button)
        self.settings_button.clicked.connect(self.settings_window)

        self.minimize_button = QPushButton("—")
        self.minimize_button.setToolTip('Minimize window')
        self.minimize_button.setFixedSize(24, 24)
        self.minimize_button.setStyleSheet(
            "QPushButton { color: white; background-color: transparent; }"
            "QPushButton:hover { background-color: green; }"
        )
        hbox_title_layout.addWidget(self.minimize_button)
        self.minimize_button.clicked.connect(self.showMinimized)

        self.close_button = QPushButton("✕")
        self.close_button.setToolTip('Close window')
        self.close_button.setFixedSize(24, 24)
        self.close_button.setStyleSheet(
            "QPushButton { color: white; background-color: transparent; }"
            "QPushButton:hover { background-color: red; }"
        )
        hbox_title_layout.addWidget(self.close_button)
        self.close_button.clicked.connect(self.close)

        hbox_title_layout.setAlignment(Qt.AlignRight)

    # Mouse events allow the title bar to be dragged around
    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton and event.y() <= self.title_bar.height():
            self.draggable = True
            self.offset = event.globalPos() - self.pos()

    def mouseMoveEvent(self, event):
        if hasattr(self, 'draggable') and self.draggable:
            if event.buttons() & Qt.LeftButton:
                self.move(event.globalPos() - self.offset)

    def mouseReleaseEvent(self, event):
        if event.button() == Qt.LeftButton:
            self.draggable = False

    def setup_ui(self):
        # Window setup
        self.setWindowTitle(f'Music Organizer v{self.version}')
        self.setWindowIcon(QIcon(':/Octopus.ico'))
        self.setGeometry(100, 100, 400, 260) # Set initial size of window (x, y, width, height)

        # Main layout
        main_layout = QVBoxLayout(self)

        # Custom title bar
        self.setup_titlebar()
        main_layout.addWidget(self.title_bar)

        # Central widget
        self.central_widget = QWidget(self)
        main_layout.addWidget(self.central_widget)

        # QVBoxLayout for central widget
        vbox_main_layout = QVBoxLayout(self.central_widget)

        # Create music folder select button
        self.music_folder_select_button = QPushButton('Select Music Folder')
        vbox_main_layout.addWidget(self.music_folder_select_button)
        self.music_folder_select_button.clicked.connect(self.select_music_folder)

        # Create music folder label
        self.music_folder_label = QLabel(self.music_folder_path)
        vbox_main_layout.addWidget(self.music_folder_label)

        # Create destination folder select button
        self.destination_folder_select_button = QPushButton('Select Destination Folder')
        vbox_main_layout.addWidget(self.destination_folder_select_button)
        self.destination_folder_select_button.clicked.connect(self.select_destination_folder)

        # Create destination folder label
        self.destination_folder_label = QLabel(self.destination_folder_path)
        vbox_main_layout.addWidget(self.destination_folder_label)

        # Add a spacer item to create an empty line
        spacer_item = QSpacerItem(30, 20, QSizePolicy.Minimum, QSizePolicy.Expanding)
        vbox_main_layout.addItem(spacer_item)

        # Create organize button
        self.organize_button = QPushButton('Organize')
        # Check if settings are empty
        if not self.music_folder_path or not self.destination_folder_path:
            self.organize_button.setEnabled(False)
        else:
            self.organize_button.setEnabled(True)
        vbox_main_layout.addWidget(self.organize_button)
        self.organize_button.clicked.connect(self.organize_function)

        # Create label for number of songs
        self.number_songs_label = QLabel("")
        vbox_main_layout.addWidget(self.number_songs_label)

        # QHBoxLayout setup for progress bar and grip
        hbox_progress_grip_layout = QHBoxLayout()
        vbox_main_layout.addLayout(hbox_progress_grip_layout)

        # Create progress bar
        self.music_progress_bar = QProgressBar()
        self.music_progress_bar.setValue(0)
        self.music_progress_bar.setMaximum(100)
        hbox_progress_grip_layout.addWidget(self.music_progress_bar)

        # Add resizing handles
        self.bottom_right_grip = QSizeGrip(self)
        self.bottom_right_grip.setToolTip('Resize window')
        hbox_progress_grip_layout.addWidget(self.bottom_right_grip, 0, Qt.AlignBottom | Qt.AlignRight)

    def center_window(self):
        screen = QApplication.desktop().screenGeometry()
        window_size = self.geometry()
        x = (screen.width() - window_size.width()) // 2
        y = (screen.height() - window_size.height()) // 2
        self.move(x, y)

    def select_music_folder(self):
        music_folder_path = QFileDialog.getExistingDirectory(self, 'Select Music Folder')
        if music_folder_path:
            self.music_folder_path = music_folder_path
            self.music_folder_label.setText(self.music_folder_path)
            # Check if settings are empty
            if not self.music_folder_path or not self.destination_folder_path:
                self.organize_button.setEnabled(False)
            else:
                self.organize_button.setEnabled(True)
            self.reset_progress_songs_label()

    def select_destination_folder(self):
        destination_folder_path = QFileDialog.getExistingDirectory(self, 'Select Destination Folder')
        if destination_folder_path:
            self.destination_folder_path = destination_folder_path
            self.destination_folder_label.setText(self.destination_folder_path)
            # Check if settings are empty
            if not self.music_folder_path or not self.destination_folder_path:
                self.organize_button.setEnabled(False)
            else:
                self.organize_button.setEnabled(True)
            self.reset_progress_songs_label()

    def reset_progress_songs_label(self):
        self.music_progress_bar.setValue(0)  # Reset the progress bar to 0
        self.music_progress_bar.setStyleSheet("") # Reset the style sheet to default
        self.number_songs_label.setText('') # Reset number of songs label

    def load_settings(self):
        try:
            with open('settings_jmo.json', 'r') as f:
                self.settings = json.load(f)
                self.music_folder_path = self.settings.get("music_folder_path", "")
                self.destination_folder_path = self.settings.get("destination_folder_path", "")

                # Update the labels with the loaded values
                self.music_folder_label.setText(self.music_folder_path)
                self.destination_folder_label.setText(self.destination_folder_path)

                # Check if settings are empty
                if not self.music_folder_path or not self.destination_folder_path:
                    self.organize_button.setEnabled(False)
                else:
                    self.organize_button.setEnabled(True)
        except FileNotFoundError:
            # Initialize self.settings dictionary
            self.settings = {}

    def organize_function(self):
        # Disable UI elements
        self.user_interface(False)
        # Variables needed in OrganizeThread
        info = {
            'selected_music_folder_path':self.music_folder_path,
            'selected_destination_folder_path':self.destination_folder_path
        }
        self.organize_thread = OrganizeThread(info)
        self.organize_thread.number_songs_signal.connect(self.number_songs)
        self.organize_thread.music_progress_signal.connect(self.music_progress)
        self.organize_thread.kill_thread_signal.connect(self.kill_thread)
        self.organize_thread.custom_dialog_signal.connect(self.custom_dialog_function)
        self.organize_thread.organize_finish_signal.connect(self.organize_finish)
        self.organize_thread.start()

    def user_interface(self, msg):
        # Define a list of UI elements to enable/disable
        ui_elements = [self.destination_folder_select_button, self.music_folder_select_button,
                    self.organize_button, self.close_button, self.settings_button]

        # Set the enabled state of each element based on the value of msg
        enabled = msg
        for element in ui_elements:
            element.setEnabled(enabled)

    def number_songs(self, msg):
        self.number_songs_label.setText(f'Number of songs found: {msg}')
        if msg:
            # Initialize progress bar at zero percent
            self.music_progress(0)

    def music_progress(self, msg):
        self.music_progress_bar.setValue(int(msg))
        if self.music_progress_bar.value() == self.music_progress_bar.maximum():
            # Update the style sheet for the progress bar
            self.music_progress_bar.setStyleSheet("""
                QProgressBar {
                    border: 1px solid black;
                    text-align: center;
                    color: black;
                    background-color: rgba(255, 152, 152, 1);
                }

                QProgressBar::chunk {
                    background-color: rgba(255, 152, 152, 1);
                }
            """)
        else:
            # Check if the current style sheet is different from an empty string
            if self.music_progress_bar.styleSheet() != "":
                # Reset the style sheet to default
                self.music_progress_bar.setStyleSheet("")
            
    def kill_thread(self, msg):
        if msg == 'organize'and hasattr(self, 'organize_thread'):
            # Delete OrganizeThread if it exists
            del self.organize_thread
            # Re-enable UI elements
            self.user_interface(True)
        if msg == 'notification' and hasattr(self, 'notification_thread'):
            # Delete NotificationAudioThread if it exists
            del self.notification_thread

    def custom_dialog_function(self, msg):
        if msg:
            # No songs were found
            custom_dialog = CustomDialog(msg)
            custom_dialog.exec_()

    def organize_finish(self, recall_files):
        self.kill_thread('organize')
        # Save recall_files for other functions
        self.recall_files = recall_files
        # Replace or Skip Files
        if recall_files['replace_skip_files']:
            if not self.settings.get('mute_sound', False):
                # Play ding sound (name of file)
                self.notification_thread = NotificationAudioThread('audio_ding')
                self.notification_thread.kill_thread_signal.connect(self.kill_thread)
                self.notification_thread.start()
            self.organize_replace_skip()
        else:
            self.replace_skip_finish()

    def organize_replace_skip(self):
        if self.recall_files['replace_skip_files']:
            # Music File Replace Skip Window
            self.music_replace_skip_window = ReplaceSkipWindow(self.recall_files['replace_skip_files'])
            self.music_replace_skip_window.windowClosed.connect(self.replace_skip_finish)
            self.music_replace_skip_window.windowOpened.connect(self.user_interface)
            self.music_replace_skip_window.show()
            
    def replace_skip_finish(self):
        self.user_interface(True)
        # Set progress bar to maximum
        self.music_progress(self.music_progress_bar.maximum())
        if self.recall_files['error_files']:
            if not self.settings.get('mute_sound', False):
                # Play ding sound (name of file)
                self.notification_thread = NotificationAudioThread('audio_ding')
                self.notification_thread.kill_thread_signal.connect(self.kill_thread)
                self.notification_thread.start()
            self.organize_error()
        elif not self.settings.get('mute_sound', False):
            # Play complete sound (name of file)
            self.notification_thread = NotificationAudioThread('audio_complete')
            self.notification_thread.kill_thread_signal.connect(self.kill_thread)
            self.notification_thread.start()

    def organize_error(self):
        if self.recall_files['error_files']:
            # Music File Error Window
            self.music_error_window = MusicErrorWindow(self.recall_files['error_files'])
            self.music_error_window.windowClosed.connect(self.user_interface)
            self.music_error_window.windowOpened.connect(self.user_interface)
            self.music_error_window.custom_dialog_signal.connect(self.custom_dialog_function)
            self.music_error_window.show()

    def settings_window(self):
        # Settings Window
        self.music_error_window = SettingsWindow()
        self.music_error_window.windowClosed.connect(self.settings_finish)
        self.music_error_window.windowOpened.connect(self.user_interface)
        self.music_error_window.show()

    def settings_finish(self):
        self.user_interface(True)
        # Load settings from file if it exists
        self.load_settings()
        self.reset_progress_songs_label()
    
</code></pre>
<h3 class="mb-3">Code (organize_thread.py)</h3>
<pre class="mb-3"><code class="language-python">
from PyQt5.QtCore import QThread, pyqtSignal
from pathlib import Path
import mutagen
from mutagen.asf import ASFUnicodeAttribute
import shutil
from resources_rc import *

class OrganizeThread(QThread):
    number_songs_signal = pyqtSignal(int)
    music_progress_signal = pyqtSignal(int)
    kill_thread_signal = pyqtSignal(str)
    custom_dialog_signal = pyqtSignal(str)
    organize_finish_signal = pyqtSignal(dict)

    def __init__(self, info):
        super().__init__()
        self.info = info

    def __del__(self):
        self.wait()

    def run(self):
        # Future Reference | These file types did not work when tested with v2.07: aac, ac3, adts, mp1, ofr, ofs, tta, wv
        extensions = [".aif", ".aiff", ".ape", ".flac", ".m4a", ".m4b", ".m4r", ".mp2", ".mp3", ".mp4", ".mpc", ".ogg", ".opus", ".wav", ".wma"]

        # Generate list of paths to music files
        pathlist = []
        for extension in extensions:
            pathlist.extend(list(Path(self.info['selected_music_folder_path']).glob(f"**/*{extension}")))

        # Update number of songs label
        total_number_of_songs = len(pathlist)
        self.number_songs_signal.emit(total_number_of_songs)

        # Define the artist and album values to search for
        artist_values = ['©art', 'artist', 'author', 'tpe1']
        album_values = ['©alb', 'album', 'talb', 'wm/albumtitle']

        # Check if folder has any songs
        if total_number_of_songs:

            # Initialize a dictionary to store file info for songs with errors
            recall_files = {
                'error_files': [],
                'replace_skip_files': []
            }

            # Dont include replace_skip_files in progress bar
            i = 0

            # Loop through each song and organize it
            for path in pathlist:
                # Replace backslashes with forward slashes
                path_in_str = str(path).replace('\\', '/')
                # Get file name from path
                file_name = path_in_str.split("/")[-1]

                # Reset variables
                artist_data = ''
                album_data = ''
                metadata_dict = {}
                file_info = {}

                try:
                    # Load and extract metadata from the music file
                    metadata = mutagen.File(path_in_str)

                    # Iterate over the metadata items and add them to the dictionary
                    for key, value in metadata.items():
                        metadata_dict[key] = value

                    # Loop through the metadata to find matching artist and album values
                    for key, value in metadata.items():
                        lowercase_key = key.lower()
                        if lowercase_key in artist_values:
                            artist_data = value
                        elif lowercase_key in album_values:
                            album_data = value

                    # Check if artist_data and album_data were found
                    if artist_data == '' or album_data == '':
                        raise Exception("Artist or album data not found")

                    # Convert the metadata values to strings
                    artist = str(artist_data[0]) if isinstance(artist_data[0], ASFUnicodeAttribute) else artist_data[0]
                    album = str(album_data[0]) if isinstance(album_data[0], ASFUnicodeAttribute) else album_data[0]

                    # Remove unwanted characters and whitespace
                    artist = artist.translate(str.maketrans("", "", ':*?<>|')).replace('/', '').replace('\\', '').replace('"', '').replace("'", '').replace('...', '').strip()
                    album = album.translate(str.maketrans("", "", ':*?<>|')).replace('/', '').replace('\\', '').replace('"', '').replace("'", '').replace('...', '').strip()

                    # Construct new location
                    new_location = f"{self.info['selected_destination_folder_path']}/{artist}/{album}"

                    # Check if the file already exists in the new location
                    if Path(f"{new_location}/{file_name}").exists():
                        file_info = {
                            'file_name': file_name,
                            'new_location': new_location,
                            'path_in_str': path_in_str,
                            'error': 'File already exists in the destination folder'
                        }

                        recall_files['replace_skip_files'].append(file_info)
                    else:
                        # Create directory and copy file to new location
                        Path(new_location).mkdir(parents=True, exist_ok=True)
                        shutil.copy(path_in_str, f"{new_location}/{file_name}")

                except Exception as e:
                    file_info = {
                        'file_name': file_name,
                        'artist_found': artist_data,
                        'album_found': album_data,
                        'metadata_dict': metadata_dict,
                        'error': str(e)
                    }

                    recall_files['error_files'].append(file_info)

                finally:
                    # Update progress bar if no error or 'File already exists'
                    if not file_info.get('error') or file_info.get('error') != 'File already exists in the destination folder':
                        i += 1
                        self.music_progress_signal.emit(int(i / len(pathlist) * 100))

            # Send recall_files
            self.organize_finish_signal.emit(recall_files)

        else:
            # No songs were found
            self.custom_dialog_signal.emit('No songs were found in the selected folder.')
            # Kill OrganizeThread QThread
            self.kill_thread_signal.emit('organize')
    
</code></pre>
<h3 class="mb-3">Code (custom_dialog.py)</h3>
<pre class="mb-3"><code class="language-python">
from PyQt5.QtWidgets import (QDialog, QVBoxLayout, QHBoxLayout, QWidget, QLabel, QPushButton, QApplication)
from PyQt5.QtCore import Qt
from PyQt5.QtGui import QIcon
import json
from resources_rc import *

# Other classes within files
from notification_audio_thread import NotificationAudioThread

class CustomDialog(QDialog):
    def __init__(self, custom_message):
        super().__init__()

        # Version Control
        self.version = '3.06'

        # Set notification thread variable
        self.notification_thread = None

        # Hides the default titlebar
        self.setWindowFlag(Qt.FramelessWindowHint)

        # Window title, icon, and size
        self.setWindowTitle(f'Alert v{self.version}')
        self.setWindowIcon(QIcon(':/Octopus.ico'))

        # Main layout
        layout = QVBoxLayout()

        # Custom title bar widget
        title_bar_widget = QWidget()
        layout.addWidget(title_bar_widget)

        # Title bar layout
        title_layout = QHBoxLayout()

        # Icon top left
        icon_label = QLabel()
        icon_label.setPixmap(QIcon(':/Octopus.ico').pixmap(24, 24))
        title_layout.addWidget(icon_label)

        title_label = QLabel(f"Alert v{self.version}")
        title_layout.addWidget(title_label)

        title_layout.addStretch()

        close_button = QPushButton("X")
        close_button.setToolTip('Close window')
        close_button.setFixedSize(24, 24)
        close_button.setStyleSheet(
            "QPushButton { color: white; background-color: transparent; }"
            "QPushButton:hover { background-color: red; }"
        )
        title_layout.addWidget(close_button)
        close_button.clicked.connect(self.reject)

        title_bar_widget.setLayout(title_layout)

        # Error message label
        error_label = QLabel(custom_message)
        error_label.setAlignment(Qt.AlignCenter)
        layout.addWidget(error_label)
        self.setLayout(layout)

        # Apply stylesheet for red border
        self.setStyleSheet("QDialog { border: 2px solid rgba(255, 152, 152, 1); }")

    def center_window(self):
        screen = QApplication.desktop().screenGeometry()
        window_size = self.geometry()
        x = (screen.width() - window_size.width()) // 2
        y = (screen.height() - window_size.height()) // 2
        self.move(x, y)

    def showEvent(self, event):
        # Load settings from file if it exists
        self.load_settings()
        if not self.settings.get('mute_sound', False):
            self.notification_thread = NotificationAudioThread('audio_ding') # (name of file)
            self.notification_thread.start()
        super().showEvent(event)
        self.center_window()

    def closeEvent(self, event):
        if self.notification_thread.isRunning():
            self.notification_thread.terminate()
        super().closeEvent(event)
        # Wait for the thread to finish before quitting the application
        self.notification_thread.wait()
        
    def load_settings(self):
        try:
            with open('settings_jmo.json', 'r') as f:
                self.settings = json.load(f)

        except FileNotFoundError:
            # Initialize self.settings dictionary
            self.settings = {}
            
</code></pre>
<h3 class="mb-3">Code (replace_skip_window.py)</h3>
<pre class="mb-3"><code class="language-python">
from PyQt5.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QLabel, QListWidget, QPushButton, QApplication, QSizeGrip, QProgressBar)
from PyQt5.QtCore import pyqtSignal, Qt
from PyQt5.QtGui import QIcon
from pathlib import Path
import shutil

class ReplaceSkipWindow(QWidget):
    windowOpened = pyqtSignal(bool)
    windowClosed = pyqtSignal(bool)

    def __init__(self, replace_skip_files):
        super().__init__()

        # Version Control
        self.version = '3.06'

        self.replace_skip_files = replace_skip_files
        self.total_entries = len(self.replace_skip_files)

        # Setup and show user interface
        self.setup_ui()

    def showEvent(self, event):
        self.windowOpened.emit(False)
        super().showEvent(event)
        self.center_window()

    def closeEvent(self, event):
        self.windowClosed.emit(True)
        super().closeEvent(event)

    def setup_titlebar(self):
        # Hides the default titlebar
        self.setWindowFlag(Qt.FramelessWindowHint)

        # Title bar widget
        self.title_bar = QWidget(self)
        self.title_bar.setObjectName("TitleBar")
        self.title_bar.setFixedHeight(32)

        hbox_title_layout = QHBoxLayout(self.title_bar)
        hbox_title_layout.setContentsMargins(0, 0, 0, 0)

        self.icon_label = QLabel()
        self.icon_label.setPixmap(QIcon(':/Octopus.ico').pixmap(24, 24))
        hbox_title_layout.addWidget(self.icon_label)

        self.title_label = QLabel(f"Replace or Skip Files Window v{self.version}")
        self.title_label.setStyleSheet("color: white;")
        hbox_title_layout.addWidget(self.title_label)

        hbox_title_layout.addStretch()

    # Mouse events allow the title bar to be dragged around
    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton and event.y() <= self.title_bar.height():
            self.draggable = True
            self.offset = event.globalPos() - self.pos()

    def mouseMoveEvent(self, event):
        if hasattr(self, 'draggable') and self.draggable:
            if event.buttons() & Qt.LeftButton:
                self.move(event.globalPos() - self.offset)

    def mouseReleaseEvent(self, event):
        if event.button() == Qt.LeftButton:
            self.draggable = False

    def setup_ui(self):
        # Window setup
        self.setWindowTitle(f"Replace or Skip Files Window v{self.version}")
        self.setWindowIcon(QIcon(':/Octopus.ico'))

        # Main layout
        main_layout = QVBoxLayout(self)

        # Custom title bar
        self.setup_titlebar()
        main_layout.addWidget(self.title_bar)

        # Central widget
        self.central_widget = QWidget(self)
        main_layout.addWidget(self.central_widget)

        # QVBoxLayout for central widget
        vbox_main_layout = QVBoxLayout(self.central_widget)

        # QLabel setup
        self.label = QLabel()
        vbox_main_layout.addWidget(self.label)

        # QListWidget setup
        self.list_widget = QListWidget()
        vbox_main_layout.addWidget(self.list_widget)

        # QHBoxLayout setup for buttons
        hbox_button_layout = QHBoxLayout()
        vbox_main_layout.addLayout(hbox_button_layout)

        # "Skip File" button setup
        self.skip_file_button = QPushButton("Skip File")
        hbox_button_layout.addWidget(self.skip_file_button)
        self.skip_file_button.clicked.connect(self.skip_file)

        # "Skip All" button setup
        self.skip_all_button = QPushButton("Skip All")
        hbox_button_layout.addWidget(self.skip_all_button)
        self.skip_all_button.clicked.connect(self.skip_all)

        # "Replace File" button setup
        self.replace_file_button = QPushButton("Replace File")
        hbox_button_layout.addWidget(self.replace_file_button)
        self.replace_file_button.clicked.connect(self.replace_file)

        # "Replace All" button setup
        self.replace_all_button = QPushButton("Replace All")
        hbox_button_layout.addWidget(self.replace_all_button)
        self.replace_all_button.clicked.connect(self.replace_all)

        # QHBoxLayout setup for progress bar and grip
        hbox_progress_grip_layout = QHBoxLayout()
        vbox_main_layout.addLayout(hbox_progress_grip_layout)

        # Create progress bar
        self.music_progress_bar = QProgressBar()
        self.music_progress_bar.setValue(0)
        self.music_progress_bar.setMaximum(100)
        hbox_progress_grip_layout.addWidget(self.music_progress_bar)

        # Add resizing handles
        self.bottom_right_grip = QSizeGrip(self)
        self.bottom_right_grip.setToolTip('Resize window')
        hbox_progress_grip_layout.addWidget(self.bottom_right_grip, 0, Qt.AlignBottom | Qt.AlignRight)

        # Populate QListWidget
        self.populate_list_widget()

        # Connect signal for item selection change in QListWidget
        self.list_widget.itemSelectionChanged.connect(self.update_label)

        # Update the label initially
        self.update_label()

    def center_window(self):
        screen = QApplication.desktop().screenGeometry()
        window_size = self.geometry()
        x = (screen.width() - window_size.width()) // 2
        y = (screen.height() - window_size.height()) // 2
        self.move(x, y)

    def populate_list_widget(self):
        # Add each entry's 'file_name' to QListWidget
        for entry in self.replace_skip_files:
            self.list_widget.addItem(entry['file_name'])

        # Set the initial selected item in QListWidget
        self.list_widget.setCurrentRow(0)

    def update_label(self):
        selected_item = self.list_widget.currentItem()
        if selected_item:
            selected_file = selected_item.text()
            selected_entry = next(
                (entry for entry in self.replace_skip_files if entry['file_name'] == selected_file), None)
            if selected_entry:
                self.label.setText(f"The destination:\n{selected_entry['new_location']}\nAlready has a file named:\n{selected_entry['file_name']}")
        else:
            self.label.clear()

    def skip_file(self):
        selected_file = self.list_widget.currentItem().text()
        selected_entry = next(
            (entry for entry in self.replace_skip_files if entry['file_name'] == selected_file), None)
        if selected_entry:
            self.replace_skip_files.remove(selected_entry)
            self.list_widget.takeItem(self.list_widget.currentRow())
            self.update_label()

        remaining_entries = self.list_widget.count()
        if remaining_entries > 0:
            progress_value = int((1 - (remaining_entries / self.total_entries)) * 100)
        else:
            progress_value = self.music_progress_bar.maximum()
        self.music_progress_bar.setValue(progress_value)

        if remaining_entries == 0:
            self.close()

    def skip_all(self):
        self.replace_skip_files.clear()
        self.list_widget.clear()
        self.label.clear()
        self.music_progress_bar.setValue(self.music_progress_bar.maximum())
        self.close()

    def replace_file(self):
        selected_file = self.list_widget.currentItem().text()
        selected_entry = next(
            (entry for entry in self.replace_skip_files if entry['file_name'] == selected_file), None)
        if selected_entry:
            self.replace_file_action(selected_entry)
            self.skip_file()

    def replace_all(self):
        while self.list_widget.count() > 0:
            selected_file = self.list_widget.item(0).text()
            selected_entry = next(
                (entry for entry in self.replace_skip_files if entry['file_name'] == selected_file), None)
            if selected_entry:
                self.replace_file_action(selected_entry)
                self.skip_file()

    def replace_file_action(self, entry):
        new_location = entry['new_location']
        file_name = entry['file_name']
        path_in_str = entry['path_in_str']

        Path(new_location).mkdir(parents=True, exist_ok=True)
        shutil.copy(path_in_str, f"{new_location}/{file_name}")
    
</code></pre>
<h3 class="mb-3">Code (music_error_window.py)</h3>
<pre class="mb-3"><code class="language-python">
from PyQt5.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QSizeGrip, QLabel, QPushButton, QSizePolicy, QListWidget, QTextEdit, QApplication, QFileDialog)
from PyQt5.QtCore import pyqtSignal, Qt, QTimer
from PyQt5.QtGui import QIcon
import openpyxl
import json
import csv

class MusicErrorWindow(QWidget):
    windowOpened = pyqtSignal(bool)
    windowClosed = pyqtSignal(bool)
    custom_dialog_signal = pyqtSignal(str)

    def __init__(self, error_files):
        super().__init__()

        # Version Control
        self.version = '3.06'

        self.error_files = error_files

        # Setup and show user interface
        self.setup_ui()

    def showEvent(self, event):
        self.windowOpened.emit(False)
        super().showEvent(event)
        self.center_window()

    def closeEvent(self, event):
        self.windowClosed.emit(True)
        super().closeEvent(event)

    def setup_titlebar(self):
        # Hides the default titlebar
        self.setWindowFlag(Qt.FramelessWindowHint)

        # Title bar widget
        self.title_bar = QWidget(self)
        self.title_bar.setObjectName("TitleBar")
        self.title_bar.setFixedHeight(32)

        hbox_title_layout = QHBoxLayout(self.title_bar)
        hbox_title_layout.setContentsMargins(0, 0, 0, 0)

        self.icon_label = QLabel()
        self.icon_label.setPixmap(QIcon(':/Octopus.ico').pixmap(24, 24))
        hbox_title_layout.addWidget(self.icon_label)

        self.title_label = QLabel(f"Music Error Window v{self.version}")
        self.title_label.setStyleSheet("color: white;")
        hbox_title_layout.addWidget(self.title_label)

        hbox_title_layout.addStretch()

        self.close_button = QPushButton("✕")
        self.close_button.setToolTip('Close window')
        self.close_button.setFixedSize(24, 24)
        self.close_button.setStyleSheet(
            "QPushButton { color: white; background-color: transparent; }"
            "QPushButton:hover { background-color: red; }"
        )
        hbox_title_layout.addWidget(self.close_button)
        self.close_button.clicked.connect(self.close)

        hbox_title_layout.setAlignment(Qt.AlignRight)

    # Mouse events allow the title bar to be dragged around
    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton and event.y() <= self.title_bar.height():
            self.draggable = True
            self.offset = event.globalPos() - self.pos()

    def mouseMoveEvent(self, event):
        if hasattr(self, 'draggable') and self.draggable:
            if event.buttons() & Qt.LeftButton:
                self.move(event.globalPos() - self.offset)

    def mouseReleaseEvent(self, event):
        if event.button() == Qt.LeftButton:
            self.draggable = False

    def setup_ui(self):
        # Window title, icon, and size
        self.setWindowTitle(f"Music Error Window v{self.version}")
        self.setWindowIcon(QIcon(':/Octopus.ico'))

        # Main layout
        main_layout = QVBoxLayout(self)

        # Custom title bar
        self.setup_titlebar()
        main_layout.addWidget(self.title_bar)

        # Central widget
        self.central_widget = QWidget(self)
        main_layout.addWidget(self.central_widget)

        # QVBoxLayout for central widget
        vbox_main_layout = QVBoxLayout(self.central_widget)

        # QHBoxLayout setup for file list and test box
        hbox_list_text_layout = QHBoxLayout()
        vbox_main_layout.addLayout(hbox_list_text_layout)

        # Create the file list widget on the top
        self.file_list_widget = QListWidget(self)
        hbox_list_text_layout.addWidget(self.file_list_widget)
        self.file_list_widget.currentItemChanged.connect(self.displayDetails)

        # QLabel for text details
        text_label = QLabel(self)
        text_label.setText("Files that don't have any metadata are unreadable by mutagen\n\n"
                        "These are the known audio file keys that are being looked for:\n"
                        "(capitalization doesn't matter)\n"
                        "artist_values = ['©art', 'artist', 'author', 'tpe1']\n"
                        "album_values = ['©alb', 'album', 'talb', 'wm/albumtitle']\n\n"
                        "These audio files have missing artist and/or album keys\n"
                        "Either:\n"
                        "- Your files don't have an artist/album name\n"
                        "- New keys need to be added to the program\n"
                        "- Your file is corrupt/tampered with")
        hbox_list_text_layout.addWidget(text_label)

        # Create the details display widget on the bottom
        self.details_display = QTextEdit(self)
        self.details_display.setReadOnly(True)
        self.details_display.setLineWrapMode(QTextEdit.NoWrap)
        vbox_main_layout.addWidget(self.details_display)

        # QHBoxLayout setup for buttons and grip
        hbox_buttons_grip_layout = QHBoxLayout()
        vbox_main_layout.addLayout(hbox_buttons_grip_layout)

        # Create the copy button
        self.copy_button = QPushButton("Copy Bottom")
        self.copy_button.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
        hbox_buttons_grip_layout.addWidget(self.copy_button)
        self.copy_button.clicked.connect(self.copyDetails)

        # Create the CSV button
        self.txt_button = QPushButton("Generate TXT File")
        self.txt_button.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
        hbox_buttons_grip_layout.addWidget(self.txt_button)
        self.txt_button.clicked.connect(self.generateTXT)

        # Create the CSV button
        self.csv_button = QPushButton("Generate CSV File")
        self.csv_button.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
        hbox_buttons_grip_layout.addWidget(self.csv_button)
        self.csv_button.clicked.connect(self.generateCSV)

        # Create the Excel button
        self.excel_button = QPushButton("Generate Excel File")
        self.excel_button.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
        hbox_buttons_grip_layout.addWidget(self.excel_button)
        self.excel_button.clicked.connect(self.generateExcel)

        # Create the JSON button
        self.json_button = QPushButton("Generate JSON File")
        self.json_button.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
        hbox_buttons_grip_layout.addWidget(self.json_button)
        self.json_button.clicked.connect(self.generateJSON)

        # Add resizing handles
        self.bottom_right_grip = QSizeGrip(self)
        self.bottom_right_grip.setToolTip('Resize window')
        hbox_buttons_grip_layout.addWidget(self.bottom_right_grip, 0, Qt.AlignBottom | Qt.AlignRight)

        # Populate QListWidget
        self.populate_list_widget()

    def center_window(self):
        screen = QApplication.desktop().screenGeometry()
        window_size = self.geometry()
        x = (screen.width() - window_size.width()) // 2
        y = (screen.height() - window_size.height()) // 2
        self.move(x, y)

    def populate_list_widget(self):
        # Populate the file list
        for info in self.error_files:
            file_name = info['file_name']
            self.file_list_widget.addItem(file_name)

        # Set the first item as the current row 
        self.file_list_widget.setCurrentRow(0)

    def displayDetails(self, current_item):
        if current_item is None:
            return

        # Get the selected file name
        selected_file = current_item.text()

        # Find the corresponding error_info
        selected_info = next((info for info in self.error_files if info['file_name'] == selected_file), None)

        # Update the details display with file name, error, artist_found, album_found, and metadata information
        if selected_info:
            file_name = selected_info['file_name']
            error = selected_info['error']
            artist_found = selected_info['artist_found']
            album_found = selected_info['album_found']
            metadata_dict = selected_info['metadata_dict']

            details_text = f"File Name: {file_name}\n"
            details_text += f"Error: {error}\n"
            if artist_found:
                details_text += f"Artist Found: {artist_found[0]}\n"
            else:
                details_text += f"Artist Found: False\n"
            if album_found:
                details_text += f"Album Found: {album_found[0]}\n\n"
            else:
                details_text += f"Album Found: False\n\n"
            details_text += "Metadata:\n"
            if metadata_dict:
                for key, value in metadata_dict.items():
                    details_text += f"{key}: {value}\n"
            else:
                details_text += "No metadata available\n"

            self.details_display.setPlainText(details_text)

    def copyDetails(self):
        clipboard = QApplication.clipboard()
        clipboard.setText(self.details_display.toPlainText())

        # Update the button text and color temporarily
        self.copy_button.setText("Success")
        self.copy_button.setStyleSheet("""
            background-color: rgba(255, 152, 152, 1);
            color: black;
        """)

        # Stop any existing copy timers before creating a new one
        if hasattr(self, "reset_copy_timer"):
            self.reset_copy_timer.stop()

        # Create a new copy timer to reset the button text and color after 1 seconds
        self.reset_copy_timer = QTimer(self)
        self.reset_copy_timer.timeout.connect(self.resetCopyButton)
        self.reset_copy_timer.start(1000)

    def resetCopyButton(self):
        self.copy_button.setText("Copy Bottom")
        self.copy_button.setStyleSheet("")

    def generateTXT(self):
        file_name, _ = QFileDialog.getSaveFileName(self, "Save TXT", "", "Text Files (*.txt)")
        if file_name:
            try:
                with open(file_name, 'w', encoding='utf-8') as file:
                    for info in self.error_files:
                        file.write(f"File Name: {info['file_name']}\n")
                        file.write(f"Error: {info['error']}\n")
                        if info['artist_found']:
                            file.write(f"Artist Found: {info['artist_found'][0]}\n")
                        else:
                            file.write("Artist Found: False\n")
                        if info['album_found']:
                            file.write(f"Album Found: {info['album_found'][0]}\n\n")
                        else:
                            file.write("Album Found: False\n\n")
                        file.write("Metadata:\n")
                        metadata_dict = info['metadata_dict']
                        if metadata_dict:
                            for key, value in metadata_dict.items():
                                file.write(f"{key}: {value}\n")
                        else:
                            file.write("No metadata available\n")
                        file.write("\n")

                    # Update the button text and color temporarily
                    self.txt_button.setText("Success")
                    self.txt_button.setStyleSheet("""
                        background-color: rgba(255, 152, 152, 1);
                        color: black;
                    """)

                    # Stop any existing txt timers before creating a new one
                    if hasattr(self, "reset_txt_timer"):
                        self.reset_txt_timer.stop()

                    # Create a new txt timer to reset the button text and color after 1 seconds
                    self.reset_txt_timer = QTimer(self)
                    self.reset_txt_timer.timeout.connect(self.resetTXTButton)
                    self.reset_txt_timer.start(1000)

            except Exception as e:
                self.custom_dialog_signal.emit('An error occurred while generating the TXT file.')
        else:
            self.custom_dialog_signal.emit('Please provide a valid file name for the TXT file.')

    def resetTXTButton(self):
        self.txt_button.setText("Generate TXT File")
        self.txt_button.setStyleSheet("")

    def generateCSV(self):
        file_name, _ = QFileDialog.getSaveFileName(self, "Save CSV", "", "CSV Files (*.csv)")
        if file_name:
            try:
                # Create a list to store all rows
                rows = []

                # Determine the maximum number of metadata fields
                max_metadata_fields = max(len(info['metadata_dict']) for info in self.error_files)

                # Generate rows
                for info in self.error_files:
                    metadata_dict = {str(key): str(value) for key, value in info['metadata_dict'].items()}

                    # Get the first value from the list if available
                    artist_found = info['artist_found'][0] if info['artist_found'] else "None"
                    album_found = info['album_found'][0] if info['album_found'] else "None"

                    # Create an empty row
                    row = [info['file_name'], info['error'], artist_found, album_found]

                    # Generate metadata keys and values for the current row
                    metadata_keys = list(metadata_dict.keys())
                    metadata_values = list(metadata_dict.values())

                    # Fill in missing metadata fields with 'None'
                    metadata_keys.extend(['None'] * (max_metadata_fields - len(metadata_keys)))
                    metadata_values.extend(['None'] * (max_metadata_fields - len(metadata_values)))

                    # Add the metadata keys and values to the row
                    for key, value in zip(metadata_keys, metadata_values):
                        row.append(key)
                        row.append(value)

                    # Add the row to the list
                    rows.append(row)

                # Determine the maximum number of columns for the header
                max_columns = max(len(row) for row in rows)

                # Fill in missing values in each row with 'None' to ensure equal length
                for row in rows:
                    row.extend(['None'] * (max_columns - len(row)))

                # Determine the column headers based on the maximum row length
                header = ['File Name', 'Error', 'Artist Found', 'Album Found']
                header.extend([f"Key {i//2 + 1}" if i % 2 == 0 else f"Value {i//2 + 1}" for i in range(max_metadata_fields*2)])

                # Write to the CSV file with UTF-8 encoding
                with open(file_name, mode='w', encoding='utf-8-sig', newline='') as file:
                    writer = csv.writer(file)
                    writer.writerow(header)
                    writer.writerows(rows)

                # Update the button text and color temporarily
                self.csv_button.setText("Success")
                self.csv_button.setStyleSheet("""
                    background-color: rgba(255, 152, 152, 1);
                    color: black;
                """)

                # Stop any existing csv timers before creating a new one
                if hasattr(self, "reset_csv_timer"):
                    self.reset_csv_timer.stop()

                # Create a new csv timer to reset the button text and color after 1 seconds
                self.reset_csv_timer = QTimer(self)
                self.reset_csv_timer.timeout.connect(self.resetCSVButton)
                self.reset_csv_timer.start(1000)

            except Exception as e:
                self.custom_dialog_signal.emit('An error occurred while generating the CSV file.')
        else:
            self.custom_dialog_signal.emit('Please provide a valid file name for the CSV.')

    def resetCSVButton(self):
        self.csv_button.setText("Generate CSV File")
        self.csv_button.setStyleSheet("")

    def generateExcel(self):
        file_name, _ = QFileDialog.getSaveFileName(self, "Save Excel", "", "Excel Files (*.xlsx)")
        if file_name:
            try:
                # Create a new workbook
                wb = openpyxl.Workbook()
                ws = wb.active

                # Generate rows
                rows = []
                max_metadata_columns = 0
                for info in self.error_files:
                    metadata_dict = {str(key): str(value) for key, value in info['metadata_dict'].items()}

                    # Extract values from the list if available
                    artist_found = info['artist_found'][0] if info['artist_found'] else "None"
                    album_found = info['album_found'][0] if info['album_found'] else "None"

                    row = [
                        info['file_name'],
                        info['error'],
                        artist_found,
                        album_found
                    ]

                    # Generate metadata keys and values for the current row
                    metadata_keys = list(metadata_dict.keys())
                    metadata_values = list(metadata_dict.values())

                    # Convert problematic values to strings before appending to the row
                    row = [str(cell) if isinstance(cell, list) else cell for cell in row]
                    metadata_values = [str(value) if isinstance(value, list) else value for value in metadata_values]

                    # Add the metadata keys and values to the row
                    for key, value in zip(metadata_keys, metadata_values):
                        row.append(key)
                        row.append(value)

                    # Add the row to the list
                    rows.append(row)

                    # Update the maximum number of metadata columns
                    max_metadata_columns = max(max_metadata_columns, len(metadata_dict) * 2)

                # Determine the maximum number of columns for the header
                max_columns = 4 + max_metadata_columns

                # Fill in missing values in each row with 'None' to ensure equal length
                for row in rows:
                    row.extend(['None'] * (max_columns - len(row)))

                # Determine the column headers based on the maximum row length
                header = ['File Name', 'Error', 'Artist Found', 'Album Found']
                header.extend([f"Key {i//2 + 1}" if i % 2 == 0 else f"Value {i//2 + 1}" for i in range(0, max_columns - 4)])

                # Write the header row
                ws.append(header)

                # Write the data rows
                for row in rows:
                    ws.append(row)

                # Auto-size columns for better visibility
                for column in ws.columns:
                    max_length = 0
                    column = [cell for cell in column]
                    for cell in column:
                        try:
                            if len(str(cell.value)) > max_length:
                                max_length = len(cell.value)
                        except:
                            pass
                    adjusted_width = (max_length + 2)
                    ws.column_dimensions[column[0].column_letter].width = adjusted_width

                # Save the Excel file
                wb.save(file_name)

                # Update the button text and color temporarily
                self.excel_button.setText("Success")
                self.excel_button.setStyleSheet("""
                    background-color: rgba(255, 152, 152, 1);
                    color: black;
                """)

                # Stop any existing excel timers before creating a new one
                if hasattr(self, "reset_excel_timer"):
                    self.reset_excel_timer.stop()

                # Create a new excel timer to reset the button text and color after 1 seconds
                self.reset_excel_timer = QTimer(self)
                self.reset_excel_timer.timeout.connect(self.resetExcelButton)
                self.reset_excel_timer.start(1000)

            except Exception as e:
                self.custom_dialog_signal.emit('An error occurred while generating the Excel file.')
        else:
            self.custom_dialog_signal.emit('Please provide a valid file name for the Excel file.')

    def resetExcelButton(self):
        self.excel_button.setText("Generate Excel File")
        self.excel_button.setStyleSheet("")

    def generateJSON(self):
        file_name, _ = QFileDialog.getSaveFileName(self, "Save JSON", "", "JSON Files (*.json)")
        if file_name:
            try:
                data = []
                for info in self.error_files:
                    metadata_dict = {str(key): str(value) for key, value in info['metadata_dict'].items()}
                    
                    artist_found = info['artist_found'][0] if info['artist_found'] else "False"
                    album_found = info['album_found'][0] if info['album_found'] else "False"
                    
                    row_data = {
                        'filename': info['file_name'],
                        'error': info['error'],
                        'artist_found': artist_found,
                        'album_found': album_found,
                        'metadata_dict': metadata_dict
                    }
                    data.append(row_data)

                with open(file_name, 'w') as file:
                    json.dump(data, file, indent=4)

                # Update the button text and color temporarily
                self.json_button.setText("Success")
                self.json_button.setStyleSheet("""
                    background-color: rgba(255, 152, 152, 1);
                    color: black;
                """)

                # Stop any existing json timers before creating a new one
                if hasattr(self, "reset_json_timer"):
                    self.reset_json_timer.stop()

                # Create a new json timer to reset the button text and color after 1 seconds
                self.reset_json_timer = QTimer(self)
                self.reset_json_timer.timeout.connect(self.resetJSONButton)
                self.reset_json_timer.start(1000)

            except Exception as e:
                self.custom_dialog_signal.emit('An error occurred while generating the JSON file.')
        else:
            self.custom_dialog_signal.emit('Please provide a valid file name for the JSON file.')

    def resetJSONButton(self):
        self.json_button.setText("Generate JSON File")
        self.json_button.setStyleSheet("")
    
</code></pre>
<h3 class="mb-3">Code (settigns_window.py)</h3>
<pre class="mb-3"><code class="language-python">
from PyQt5.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, QApplication, QSizeGrip, QCheckBox, QSpacerItem, QSizePolicy,QFrame, QFileDialog)
from PyQt5.QtCore import pyqtSignal, Qt, QTimer
from PyQt5.QtGui import QIcon
import json

class SettingsWindow(QWidget):
    windowOpened = pyqtSignal(bool)
    windowClosed = pyqtSignal(bool)

    def __init__(self):
        super().__init__()

        # Version Control
        self.version = '3.06'

        # Initialize attributes
        self.music_folder_path = ''
        self.destination_folder_path = ''

        # Setup and show user interface
        self.setup_ui()

        # Load settings from file if it exists
        self.load_settings()

    def showEvent(self, event):
        self.windowOpened.emit(False)
        super().showEvent(event)
        self.center_window()

    def closeEvent(self, event):
        self.windowClosed.emit(True)
        super().closeEvent(event)

    def setup_titlebar(self):
        # Hides the default titlebar
        self.setWindowFlag(Qt.FramelessWindowHint)

        # Title bar widget
        self.title_bar = QWidget(self)
        self.title_bar.setObjectName("TitleBar")
        self.title_bar.setFixedHeight(32)

        hbox_title_layout = QHBoxLayout(self.title_bar)
        hbox_title_layout.setContentsMargins(0, 0, 0, 0)

        self.icon_label = QLabel()
        self.icon_label.setPixmap(QIcon(':/Octopus.ico').pixmap(24, 24))
        hbox_title_layout.addWidget(self.icon_label)

        self.title_label = QLabel(f"Settings Window v{self.version}")
        self.title_label.setStyleSheet("color: white;")
        hbox_title_layout.addWidget(self.title_label)

        hbox_title_layout.addStretch()

        self.close_button = QPushButton("✕")
        self.close_button.setToolTip('Close window')
        self.close_button.setFixedSize(24, 24)
        self.close_button.setStyleSheet(
            "QPushButton { color: white; background-color: transparent; }"
            "QPushButton:hover { background-color: red; }"
        )
        hbox_title_layout.addWidget(self.close_button)
        self.close_button.clicked.connect(self.close)

        hbox_title_layout.setAlignment(Qt.AlignRight)

    # Mouse events allow the title bar to be dragged around
    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton and event.y() <= self.title_bar.height():
            self.draggable = True
            self.offset = event.globalPos() - self.pos()

    def mouseMoveEvent(self, event):
        if hasattr(self, 'draggable') and self.draggable:
            if event.buttons() & Qt.LeftButton:
                self.move(event.globalPos() - self.offset)

    def mouseReleaseEvent(self, event):
        if event.button() == Qt.LeftButton:
            self.draggable = False

    def setup_ui(self):
        # Window setup
        self.setWindowTitle(f"Settings Window v{self.version}")
        self.setWindowIcon(QIcon(':/Octopus.ico'))
        self.setGeometry(100, 100, 400, 300) # Set initial size of window (x, y, width, height)

        # Main layout
        main_layout = QVBoxLayout(self)

        # Custom title bar
        self.setup_titlebar()
        main_layout.addWidget(self.title_bar)

        # Central widget
        self.central_widget = QWidget(self)
        main_layout.addWidget(self.central_widget)

        # QVBoxLayout for central widget
        vbox_main_layout = QVBoxLayout(self.central_widget)

        # QLabel for sound
        self.sound_label = QLabel(self)
        self.sound_label.setText("Sound:")
        vbox_main_layout.addWidget(self.sound_label)

        # Create the checkbox
        self.checkbox = QCheckBox("Mute all sound")
        self.checkbox.setChecked(False)
        vbox_main_layout.addWidget(self.checkbox)

        # Add a spacer item to create an empty line
        spacer_item = QSpacerItem(30, 20, QSizePolicy.Minimum, QSizePolicy.Expanding)
        vbox_main_layout.addItem(spacer_item)

        # QLabel for music library
        self.music_label = QLabel(self)
        self.music_label.setText("Folders:")
        vbox_main_layout.addWidget(self.music_label)

        # QHBoxLayout setup for music select and music clear
        hbox_music_clear_layout = QHBoxLayout()
        vbox_main_layout.addLayout(hbox_music_clear_layout)

        # Create music folder select button
        self.music_folder_select_button = QPushButton('Set Default Music Folder')
        hbox_music_clear_layout.addWidget(self.music_folder_select_button, 1)
        self.music_folder_select_button.clicked.connect(self.select_music_folder)

        # Create music folder clear button
        self.music_folder_clear_button = QPushButton('Clear')
        hbox_music_clear_layout.addWidget(self.music_folder_clear_button)
        self.music_folder_clear_button.clicked.connect(self.clear_music_folder)

        # Create music folder label
        self.music_folder_label = QLabel(self.music_folder_path)
        vbox_main_layout.addWidget(self.music_folder_label)

        # QHBoxLayout setup for destination select and destination clear
        hbox_destination_clear_layout = QHBoxLayout()
        vbox_main_layout.addLayout(hbox_destination_clear_layout)

        # Create destination folder select button
        self.destination_folder_select_button = QPushButton('Set Default Destination Folder')
        hbox_destination_clear_layout.addWidget(self.destination_folder_select_button, 1)
        self.destination_folder_select_button.clicked.connect(self.select_destination_folder)

        # Create destination folder clear button
        self.destination_folder_clear_button = QPushButton('Clear')
        hbox_destination_clear_layout.addWidget(self.destination_folder_clear_button)
        self.destination_folder_clear_button.clicked.connect(self.clear_destination_folder)

        # Create destination folder label
        self.destination_folder_label = QLabel(self.destination_folder_path)
        vbox_main_layout.addWidget(self.destination_folder_label)

        # Add a spacer item to create an empty line
        spacer_item = QSpacerItem(30, 20, QSizePolicy.Minimum, QSizePolicy.Expanding)
        vbox_main_layout.addItem(spacer_item)

        # QHBoxLayout setup for save and reset settings
        hbox_save_reset_layout = QHBoxLayout()
        vbox_main_layout.addLayout(hbox_save_reset_layout)

        # Create save settings button
        self.save_button = QPushButton('Save Settings')
        hbox_save_reset_layout.addWidget(self.save_button, 1)
        self.save_button.clicked.connect(self.save_settings)
        
        # Create a line between the save and reset button
        line_save_reset = QFrame()
        line_save_reset.setFrameShape(QFrame.VLine)
        line_save_reset.setFrameShadow(QFrame.Sunken)
        hbox_save_reset_layout.addWidget(line_save_reset)

        # Create reset settings button
        self.reset_button = QPushButton('Reset && Save All Settings')
        hbox_save_reset_layout.addWidget(self.reset_button, 1)
        self.reset_button.clicked.connect(self.reset_settings)
        
        # Add resizing handles
        self.bottom_right_grip = QSizeGrip(self)
        self.bottom_right_grip.setToolTip('Resize window')
        hbox_save_reset_layout.addWidget(self.bottom_right_grip, 0, Qt.AlignBottom | Qt.AlignRight)

    def center_window(self):
        screen = QApplication.desktop().screenGeometry()
        window_size = self.geometry()
        x = (screen.width() - window_size.width()) // 2
        y = (screen.height() - window_size.height()) // 2
        self.move(x, y)

    def select_music_folder(self):
        music_folder_path = QFileDialog.getExistingDirectory(self, 'Select Music Folder')
        if music_folder_path:
            self.music_folder_path = music_folder_path
            self.music_folder_label.setText(self.music_folder_path)

    def clear_music_folder(self):
        self.music_folder_path = ''
        self.music_folder_label.setText('')

    def select_destination_folder(self):
        destination_folder_path = QFileDialog.getExistingDirectory(self, 'Select Destination Folder')
        if destination_folder_path:
            self.destination_folder_path = destination_folder_path
            self.destination_folder_label.setText(self.destination_folder_path)

    def clear_destination_folder(self):
        self.destination_folder_path = ''
        self.destination_folder_label.setText('')

    def load_settings(self):
        try:
            with open('settings_jmo.json', 'r') as f:
                self.settings = json.load(f)
                self.music_folder_path = self.settings.get("music_folder_path", "")
                self.destination_folder_path = self.settings.get("destination_folder_path", "")
                self.checkbox.setChecked(self.settings.get("mute_sound", False))

                # Update the labels with the loaded values
                self.music_folder_label.setText(self.music_folder_path)
                self.destination_folder_label.setText(self.destination_folder_path)
        except FileNotFoundError:
            # Initialize self.settings dictionary
            self.settings = {}

    def save_settings(self):
        # Create settings dictionary
        settings = {
            "music_folder_path": self.music_folder_path,
            "destination_folder_path": self.destination_folder_path,
            "mute_sound": self.checkbox.isChecked()
        }

        # Save settings to file
        with open('settings_jmo.json', 'w') as file:
            json.dump(settings, file, indent=4)

        # Update the button text and color temporarily
        self.save_button.setText("Success")
        self.save_button.setStyleSheet("""
            background-color: rgba(255, 152, 152, 1);
            color: black;
        """)

        # Stop any existing save timers before creating a new one
        if hasattr(self, "reset_save_timer"):
            self.reset_save_timer.stop()

        # Create a new save timer to reset the button text and color after 1 seconds
        self.reset_save_timer = QTimer(self)
        self.reset_save_timer.timeout.connect(self.resetSaveButton)
        self.reset_save_timer.start(1000)

    def resetSaveButton(self):
        self.save_button.setText("Save Settings")
        self.save_button.setStyleSheet("")

    def reset_settings(self):
        #Default settings
        self.music_folder_path = ''
        self.destination_folder_path = ''
        self.checkbox.setChecked(False)

        # Reset settings to default
        self.music_folder_label.setText(self.music_folder_path)
        self.destination_folder_label.setText(self.destination_folder_path)

        # Save settings to file
        self.save_settings()

        # Update the button text and color temporarily
        self.reset_button.setText("Success")
        self.reset_button.setStyleSheet("""
            background-color: rgba(255, 152, 152, 1);
            color: black;
        """)

        # Stop any existing reset timers before creating a new one
        if hasattr(self, "reset_reset_timer"):
            self.reset_reset_timer.stop()

        # Create a new reset timer to reset the button text and color after 1 seconds
        self.reset_reset_timer = QTimer(self)
        self.reset_reset_timer.timeout.connect(self.resetResetButton)
        self.reset_reset_timer.start(1000)

    def resetResetButton(self):
        self.reset_button.setText("Reset && Save All Settings")
        self.reset_button.setStyleSheet("")
    
</code></pre>
{% endblock content_body %}
